// 一時停止スクリプト等共通処理
let IsReplaySave = false;
let menu_on	= true;


// 解説用
let imgHelp = [
	imgDir ~ "system/help00.png",
	imgDir ~ "system/help01.png",
	imgDir ~ "system/help02.png",
	imgDir ~ "system/help03.png",
	imgDir ~ "system/help04.png",
	imgDir ~ "system/help05.png",
	];

let imgHelpCharacter = [
	imgDir ~ "system/help06.png",
	imgDir ~ "system/help07.png",
	imgDir ~ "system/help08.png",
	];

// 表示用 [min_y, max_y, 画像ファイル,フラグ]
let CharacterIndex = [
	["0", "128", imgHelpCharacter[0], BOSS_ID_TOKUBI],
	["128", "256", imgHelpCharacter[0], BOSS_ID_RINNE],
	["256", "416", imgHelpCharacter[0], BOSS_ID_MINAYU],
	["0", "128", imgHelpCharacter[1], BOSS_ID_SETUJO],
	["128", "288", imgHelpCharacter[1], BOSS_ID_KOUKAI],
	["288", "416", imgHelpCharacter[1], BOSS_ID_SASHA],
	["416", "544", imgHelpCharacter[1], BOSS_ID_UKA],
	["544", "672", imgHelpCharacter[1], BOSS_ID_RAKU],
	["0", "192", imgHelpCharacter[2], BOSS_ID_VINKA],
	["192", "352", imgHelpCharacter[2], BOSS_ID_MINT],
	["352", "704", imgHelpCharacter[2], BOSS_ID_AZUMA],
	["704", "928", imgHelpCharacter[2], BOSS_ID_KAYANO],
];
// 出会ったことのないキャラ
let CharacterNone = ["416", "480", imgHelpCharacter[0], ""];


// 文字配置
function SetSceneSelectImage(id, text)
{
	let sca		= 0.8;
	let sca2	= 1;

	alternative(text)
	case("一時停止"){
		ObjSprite2D_SetSourceRect(id,0,0,256,64);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca2,sca2,0);
		ObjRender_SetColor(id,255,255,255);
	}
	case("満身創痍"){
		ObjSprite2D_SetSourceRect(id,0,64,256,128);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca2,sca2,0);
		ObjRender_SetColor(id,255,255,255);
	}
	case("再生終了"){
		ObjSprite2D_SetSourceRect(id,0,128,256,192);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca2,sca2,0);
		ObjRender_SetColor(id,255,255,255);
	}
	case("はい"){
		ObjSprite2D_SetSourceRect(id,0,192,256,256);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca,sca,0);
	}
	case("いいえ"){
		ObjSprite2D_SetSourceRect(id,0,256,256,320);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca,sca,0);
	}
	case("本当に"){
		ObjSprite2D_SetSourceRect(id,0,320,256,384);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca,sca,0);
		ObjRender_SetColor(id,255,255,255);
	}
	case("再開"){
		ObjSprite2D_SetSourceRect(id,0,384,256,448);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca,sca,0);
	}
	case("タイトルに戻る"){
		ObjSprite2D_SetSourceRect(id,0,448,256,512);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca,sca,0);
	}
	case("最初から始める"){
		ObjSprite2D_SetSourceRect(id,0,512,256,576);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca,sca,0);
	}
	case("リプレイを保存する"){
		ObjSprite2D_SetSourceRect(id,0,576,256,640);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca,sca,0);
	}
	case("再挑戦"){
		ObjSprite2D_SetSourceRect(id,0,640,256,704);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca,sca,0);
	}
	case("操作説明"){
		ObjSprite2D_SetSourceRect(id,0,704,256,768);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca,sca,0);
	}
	case("円満解決"){
		ObjSprite2D_SetSourceRect(id,0,768,256,832);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca2,sca2,0);
	}
	case("無事解決"){
		ObjSprite2D_SetSourceRect(id,0,832,256,896);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca2,sca2,0);
	}
	case("迷宮入り"){
		ObjSprite2D_SetSourceRect(id,0,896,256,960);
		ObjSprite2D_SetDestCenter(id);
		ObjRender_SetScaleXYZ(id,sca2,sca2,0);
	}
}

//　わかめ配置
task SetWakame(parent, mx, my, color)
{
	let alpha1		= 0;
	let alphaA		= 0;
	let count		= 0;
	
	let id		= ObjPrim_Create(OBJ_SPRITE_2D);
	ObjRender_SetPosition(id, mx, my, 0 );
	ObjPrim_SetTexture(id, imgFrontPause02 );
	ObjRender_SetBlendType(id, BLEND_ADD_ARGB );
	ObjRender_SetColor(id, color[0], color[1], color[2] );
	ObjRender_SetAlpha(id, alpha1 );
	ObjRender_SetScaleXYZ(id, 1, 1, 0 );
	Obj_SetRenderPriorityI(id, 10 );
	ObjSprite2D_SetSourceRect(id, 0, 0, 128, 256 );
	ObjSprite2D_SetDestCenter(id);
	
	while( !Obj_IsDeleted(id) && !Obj_IsDeleted(parent) ){
		alpha1 = 255 * sin( alphaA );
		
		if( IsReplaySave ){
			ObjRender_SetAlpha(id, 0 );
		}
		else{
			ObjRender_SetAlpha(id, alpha1 );
		}
		ObjRender_SetAngleXYZ(id, 0, 0, (-45+alpha1/255*45)+4*sin(count*4) );
		
		count++;
		if( alpha1 < 255 ){ alphaA += 5; }
		
		yield;
	}
	Obj_Delete(id);
}


//　エフェクト
//----------------------------------------------------------------
//----------------------------------------------------------------
//　はっぱっぱ
task CreatePauseEffect(pos,angle,speed,acc,mx,rgb_h,alpha,kill){
	let ID		= ObjPrim_Create(OBJ_SPRITE_2D);
	let csd		= GetCurrentScriptDirectory();
	let dis		= 0;
	let move1	= 0;
	let moveA	= 0;
	let frame	= 0;
	let sca		= 0.5;
	let spin	= randEffect(0,360);
	let spinp	= randEffect(-2,2);
	
	ObjRender_SetPosition(ID, pos[0] + dis * cos(angle), pos[1] + dis * sin(angle), 0 );
	ObjRender_SetBlendType(ID, BLEND_ADD_ARGB );
	ObjPrim_SetTexture(ID, imgEffectParticle );
	Obj_SetRenderPriorityI(ID, 10 );
	ObjRender_SetScaleXYZ(ID, sca, sca, 0 );
	ObjSprite2D_SetSourceRect(ID, 64, 0, 128, 64 );
	ObjSprite2D_SetDestCenter(ID);
	
	while( !Obj_IsDeleted(ID) && frame < kill ){
		
		move1 = 1 * sin( moveA );
		
		ObjRender_SetPosition(ID, pos[0] + dis * cos(angle), pos[1] + dis * sin(angle), 0 );
		ObjRender_SetAngleXYZ(ID, 0, 0, spin + spinp );
		ObjRender_SetScaleXYZ(ID, sca + frame/256, sca + frame/256, 0 );
		ObjRender_SetAlpha(ID, move1*alpha );
		
		frame++;
		spin += spinp;
		dis += speed;
		if( speed < mx ){ speed += acc; }
		if( move1 < 1 ){ moveA += 2; }
		
		yield;
	}
	move1 = 0;
	moveA = 0;
	while( !Obj_IsDeleted(ID) && move1 < 1 ){
		
		move1 = 1 * sin( moveA );
		
		ObjRender_SetPosition(ID, pos[0] + dis * cos(angle), pos[1] + dis * sin(angle), 0 );
		ObjRender_SetAngleXYZ(ID, 0, 0, spin + spinp );
		ObjRender_SetScaleXYZ(ID, sca + frame/256, sca + frame/256, 0 );
		ObjRender_SetAlpha(ID, alpha - move1*alpha );
		
		frame++;
		spin += spinp;
		dis += speed;
		if( speed < mx ){ speed += acc; }
		if( move1 < 1 ){ moveA += 1; }
		
		yield;
	}
	Obj_Delete(ID);
}


// 暗転
task TBackground
{
	let filterCount = 15;
	let renderTexture = GetTransitionRenderTargetName();
	let renderTexture2 = renderTexture;	// 描画先
	
	// ベースの背景
	let objBaseBg = ObjPrim_Create(OBJ_SPRITE_2D); //2Dスプライトオブジェクト生成
	ObjPrim_SetTexture(objBaseBg, GetTransitionRenderTargetName()); //テクスチャを設定
	ObjSprite2D_SetSourceRect(objBaseBg, 0, 0, GetScreenWidth, GetScreenHeight);
	ObjSprite2D_SetDestRect(objBaseBg, 0, 0, GetScreenWidth, GetScreenHeight);
	Obj_SetRenderPriorityI(objBaseBg, 0);
	
	//--------------------------------
	//ゆがみオブジェクト
	let frameX1 = GetStgFrameLeft; let frameY1 = GetStgFrameTop;
	let frameX2 = frameX1+GetStgFrameWidth; let frameY2 = frameY1+GetStgFrameHeight;

	let objBg = ObjPrim_Create(OBJ_SPRITE_2D); //2Dスプライトオブジェクト生成
	ObjPrim_SetTexture(objBg, renderTexture); //テクスチャを設定
	ObjSprite2D_SetSourceRect(objBg, frameX1, frameY1, frameX2, frameY2);
	ObjSprite2D_SetDestRect(objBg, frameX1, frameY1, frameX2, frameY2);
	Obj_SetRenderPriorityI(objBg, 0);

	let objBg2 = ObjPrim_Create(OBJ_SPRITE_2D); //2Dスプライトオブジェクト生成
	ObjPrim_SetTexture(objBg2, renderTexture2); //テクスチャを設定
	ObjSprite2D_SetSourceRect(objBg2, frameX1, frameY1, frameX2, frameY2);
	ObjSprite2D_SetDestRect(objBg2, frameX1, frameY1, frameX2, frameY2);
	Obj_SetRenderPriorityI(objBg2, 0);

	//暗転えへくと
	let objBlack = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjSprite2D_SetDestRect(objBlack, 0, 0, GetScreenWidth, GetScreenHeight);
	ObjRender_SetColor(objBlack, 0, 0, 0);
	ObjRender_SetBlendType(objBlack, BLEND_MULTIPLY);
	Obj_SetRenderPriorityI(objBlack, 0);

	//ゆがみオブジェクトにシェーダを設定
	//フィルタの再起処理をさせたかったけど技術ぢからが足りない！→なんか分からないけど出来た！
	ObjShader_SetShaderF(objBg, hlslGaussian);
	ObjShader_SetTechnique(objBg, "TecGaussian");
	
	ascent(i in 0 .. filterCount)
	{
		RenderToTextureB1(renderTexture2, objBg, false);
		
		let tmp_c = 255 * (1-i/filterCount*0.5);
		ObjRender_SetColor(objBlack, tmp_c, tmp_c, tmp_c);
		// 少しずつ暗く
		ObjRender_SetColor(objBg, 240, 240, 240);
		yield;
	}
}

//　メニュー作成関数
task TMenuItem(parent, index, mx, my, text){
	let alpha	= 0;
	let move1	= 0;
	let moveA	= 0;
	let move2	= 0;
	let moveB	= 0;
	let move3	= 0;
	let moveC	= 0;

	let offset_text = 128;	//テキストのオフセット
	
	let objText = CreateMenuTextObject(mx, my, text);
	let objSelect = CreateMenuTextObject(mx, my, text);
	ObjRender_SetColor(objSelect, 255, 128, 128 );
	
	while(!Obj_IsDeleted(parent))
	{
		let selectIndex = Obj_GetValueD(parent, "VALUE", -1);
		
		//　選択中は横に移動
		if( index == selectIndex )
		{
			move1 = sin( moveA );
			if( move1 < 1 ){ moveA += 15; }
		}
		else
		{
			move1 = sin( moveA );
			if( move1 > 0 ){ moveA -= 15; }
		}
		
		if( IsReplaySave )
		{
			move3 = sin(moveC);
			if( move3 < 1 ){ moveC += 15; }
		}
		else{
			moveC = 0;
			move3 = 0;
		}
		ObjRender_SetAlpha(objText, alpha*(1-moveC) );
		ObjRender_SetAlpha(objSelect, alpha*(1-moveC) );
		
		let tmp_x = mx + (1-move2)*offset_text + move1*24;
		ObjRender_SetPosition(objText, tmp_x, my, 0);
		ObjRender_SetPosition(objSelect, tmp_x, my, 0);
		
		Obj_SetVisible(objSelect, index == selectIndex );
		
		alpha = min(255, alpha+15);
		if ( move2 < 1 )
		{
			moveB += 10;
			move2 = sin(moveB);
		}
		yield;
	}
	Obj_Delete(objText);
	Obj_Delete(objSelect);
}

function CreateMenuTextObject(let mx, let my, let text)
{
	let id		= ObjPrim_Create(OBJ_SPRITE_2D);
	
	ObjRender_SetPosition(id, mx, my, 0 );
	ObjPrim_SetTexture(id, imgFrontPause01 );
	ObjRender_SetBlendType(id, BLEND_ALPHA );
	ObjRender_SetAngleXYZ(id, 0, 0, 0 );
	ObjRender_SetColor(id, 64, 64, 64 );
	ObjRender_SetAlpha(id, 0 );
	Obj_SetRenderPriorityI(id, 10 );
	SetSceneSelectImage(id, text);
	return id;
}

//キーチェック  押しっぱなし時のみディレイ付き
//check_keys=感知キーを配列で
function CheckKey_Menu(key_delay, check_keys)
{
//	let tmp_flag = Menu_ReDrawFlag; //強制再描画フラグ
	let key_count = length(check_keys);
	let key_value = -1;
	let t = 0;
	while(key_value == -1)
	{
	//	if (Menu_ReDrawFlag != tmp_flag) { break; }
		if (t >= key_delay)
		{
			ascent(i in 0 .. key_count)
			{
				if (GetVirtualKeyState(check_keys[i]) == KEY_HOLD) { key_value = check_keys[i]; break; }
			}
		}
		ascent(i in 0 .. key_count)
		{
			if (GetVirtualKeyState(check_keys[i]) == KEY_PUSH) { key_value = check_keys[i]; break; }
		}
		t++;
		yield;
	}
	return(key_value);
}


function Menu_AddValue(obj, key, add_value, max_value)
{
	if (max_value <= 0) { Obj_SetValue(obj, key, 0); }
	else { Obj_SetValue(obj, key, (Obj_GetValueD(obj, key, -1)+max_value+add_value)%max_value); }
}

task TMenuBg(parent)
{
	let objText = ObjPrim_Create(OBJ_SPRITE_2D);
	Obj_SetRenderPriorityI(objText, 10);
	ObjRender_SetPosition(objText, 0, 0, 0);
	ObjSprite2D_SetDestRect(objText, 0, 0, GetScreenWidth, GetScreenHeight);
	ObjRender_SetColor(objText, 0, 0, 0);
	
	let base_alpha = 200;
	let alpha = 0;
	while(!Obj_IsDeleted(parent))
	{
		if (alpha < 1)
		{
			alpha = min(1, 0.1+alpha);
			ObjRender_SetAlpha(objText, base_alpha*alpha);
		}
		yield;
	}
	descent(t in 0 .. 10)
	{
		let alpha = base_alpha*((t+1)/10);
		ObjRender_SetAlpha(objText, alpha);
		yield;
	}
	Obj_Delete(objText);
}

//　確認よ
function TReverify(mx, my)
{
	//メニュー配置
	let texts		= [ "はい", "いいえ" ];
	let countMenu	= length(texts);
	let returnValue = false;

	//　メニュータイトル作成
	let objParent = ObjText_Create();	//適当なオブジェクトを生成（データのやり取り用）
	Obj_SetValue(objParent, "VALUE", 0);

	//　項目作成
	TMenuBg(objParent);
	SetWakame(objParent, mx-64, my-12, [60, 100, 140]);
	TMenuItem(objParent, countMenu+1, mx+32, my-46, "本当に" );
	
	ascent( var iText in 0 .. countMenu )
	{
		TMenuItem(objParent, iText, mx, my, texts[iText] );
		my += 32;
		mx += 8;
	}
	
	//キー状態がリセットされるまで待機
	WaitForResetKey();
	
	loop
	{
		//キー入力待ち
		let downKey = CheckKey_Menu(5, [VK_UP, VK_DOWN, VK_CANCEL, VK_OK]);

		alternative (downKey)
		case (VK_UP)
		{
			CallSoundPackage(sndTtSelect);
			Menu_AddValue(objParent, "VALUE", -1, countMenu);
		}
		case (VK_DOWN)
		{
			CallSoundPackage(sndTtSelect);
			Menu_AddValue(objParent, "VALUE", 1, countMenu);
		}
		case (VK_CANCEL)
		{
			Obj_SetValue(objParent, "VALUE", 0);
			CallSoundPackage(sndTtCancel);
			break;
		}
		case (VK_OK)
		{
			let selectIndex = Obj_GetValueD(objParent, "VALUE", 0);
			
			if (selectIndex == 0)
			{
				returnValue = true;
				CallSoundPackage(sndTtDecide);
			}
			else
			{
				CallSoundPackage(sndTtCancel);
			}
			break;
		}
		loop(3) { yield; }	//適当に固定ディレイ
	}
	Obj_Delete(objParent);
	if (!returnValue) { WaitForResetKey(); }
	return(returnValue);
}


function THelp()
{
	let objParent = ObjText_Create();	//適当なオブジェクトを生成（データのやり取り用）
	Obj_SetValue(objParent, "VALUE", 0);
	Obj_SetValue(objParent, "VALUE2", 0);
	Obj_SetValue(objParent, "VALUE3", 0);

	let selectMax  = 5;
	let selectMax2  = 5;
	let selectMax3  = length(CharacterIndex);
	let selectHelpCaracter = 5;
	
	//メニュー配置
	local
	{
		let bx = 240;
		let by = 64;
		
		TMenuBg(objParent);
		ascent(iObj in 0 .. selectMax)
		{
			TMenuItemHelp(objParent, iObj, bx, by);
			by += 24;
			bx -= 6;
		}
	}
	
	//キー状態がリセットされるまで待機
	WaitForResetKey();
	
	loop
	{
		//キー入力待ち
		let downKey = CheckKey_Menu(5, [VK_UP, VK_DOWN, VK_LEFT, VK_RIGHT, VK_CANCEL, VK_OK]);

		alternative (downKey)
		case (VK_LEFT)
		{
			let v2 = Obj_GetValueD(objParent, "VALUE2", 0);
			if (v2 == selectHelpCaracter)
			{
				CallSoundPackage(sndTtSelect);
				Menu_AddValue(objParent, "VALUE3", -1, selectMax3);
				CallHelpCaracter();
			}
		}
		case (VK_RIGHT)
		{
			let v2 = Obj_GetValueD(objParent, "VALUE2", 0);
			if (v2 == selectHelpCaracter)
			{
				CallSoundPackage(sndTtSelect);
				Menu_AddValue(objParent, "VALUE3", +1, selectMax3);
				CallHelpCaracter();
			}
		}
		case (VK_UP)
		{
			CallSoundPackage(sndTtSelect);
			let v2 = Obj_GetValueD(objParent, "VALUE2", 0);
			if (v2 > 0)
			{
				Obj_SetValue(objParent, "VALUE2", ((v2-1)+selectMax2-1)%selectMax2+1);
				TMenuItemHelpBase(objParent, Obj_GetValueD(objParent, "VALUE2", 0), 0, 0);
				CallHelpCaracter();
			}
			else
			{
				Menu_AddValue(objParent, "VALUE", -1, selectMax);
			}
		}
		case (VK_DOWN)
		{
			CallSoundPackage(sndTtSelect);
			let v2 = Obj_GetValueD(objParent, "VALUE2", 0);
			if (v2 > 0)
			{
				Obj_SetValue(objParent, "VALUE2", ((v2-1)+selectMax2+1)%selectMax2+1);
				TMenuItemHelpBase(objParent, Obj_GetValueD(objParent, "VALUE2", 0), 0, 0);
				CallHelpCaracter();
			}
			else
			{
				Menu_AddValue(objParent, "VALUE", +1, selectMax);
			}
		}
		case (VK_CANCEL)
		{
			let v2 = Obj_GetValueD(objParent, "VALUE2", 0);
			if (v2 > 0)
			{
				CallSoundPackage(sndTtCancel);
				Obj_SetValue(objParent, "VALUE", v2-1);
				Obj_SetValue(objParent, "VALUE2", 0);
				WaitForResetKey();
			}
			else
			{
				CallSoundPackage(sndTtCancel);
				break;
			}
		}
		case (VK_OK)
		{
			let v2 = Obj_GetValueD(objParent, "VALUE2", 0);
			if (v2 <= 0)
			{
				Obj_SetValue(objParent, "VALUE2", Obj_GetValueD(objParent, "VALUE", 0)+1);
				TMenuItemHelpBase(objParent, Obj_GetValueD(objParent, "VALUE2", 0), 0, 0);
				CallSoundPackage(sndTtDecide);
				CallHelpCaracter();
			}
		}
		loop(3) { yield; }	//適当に固定ディレイ
	}
	Obj_Delete(objParent);
	WaitForResetKey();

	function CallHelpCaracter()
	{
		let v2 = Obj_GetValueD(objParent, "VALUE2", 0);
		if (v2 == selectHelpCaracter)
		{
			let v3 = Obj_GetValueD(objParent, "VALUE3", 0);
			TMenuItemHelpCharacter(objParent, v3, 16, 64);
		}
	}
	task TMenuItemHelpCharacter(parent, index, base_x, base_y)
	{
		let c_idx = CharacterIndex[index][3];
		let imgData;
		if (CDM_GetCharacterDataFlag(c_idx)) { imgData = CharacterIndex[index]; }
		else { imgData = CharacterNone; }
		let iy_min = atoi(imgData[0]);
		let iy_max = atoi(imgData[1]);

		let objText = ObjPrim_Create(OBJ_SPRITE_2D);
		Obj_SetRenderPriorityI(objText, 91);
		ObjPrim_SetTexture(objText, imgData[2]);
		ObjRender_SetPosition(objText, base_x+64, base_y+64, 0);
		ObjSprite2D_SetSourceRect(objText, 0, iy_min, 512, iy_max);
		ObjSprite2D_SetDestRect(objText, 0, 0, 512, (iy_max-iy_min));
//		ObjRender_SetScaleXYZ(objText, 0.8, 0.8, 1);
		
		let alpha = 0;
		let before_index = Obj_GetValueD(objParent, "VALUE3", -1);
		let before_index2 = Obj_GetValueD(objParent, "VALUE2", -1);
		while(!Obj_IsDeleted(parent))
		{
			let new_index = Obj_GetValueD(objParent, "VALUE3", -1);
			let new_index2 = Obj_GetValueD(objParent, "VALUE2", -1);
			if (before_index != new_index || before_index2 != new_index2)
			{
				break;
			}
			if (alpha < 1)
			{
				alpha = min(1, 0.1+alpha);
			}
			ObjRender_SetAlpha(objText, 255*alpha);
			yield;
		}
		descent(t in 0 .. 10)
		{
			let alpha = 255*((t+1)/10);
			ObjRender_SetAlpha(objText, alpha);
			yield;
		}
		Obj_Delete(objText);
	}
	task TMenuItemHelpBase(parent, index, base_x, base_y)
	{
		let objText = ObjPrim_Create(OBJ_SPRITE_2D);
		Obj_SetRenderPriorityI(objText, 91);
		ObjPrim_SetTexture(objText, imgHelp[index]);
		ObjRender_SetPosition(objText, base_x+64, base_y+64, 0);
		ObjSprite2D_SetSourceRect(objText, 0, 0, 512, 512);
		ObjSprite2D_SetDestRect(objText, 0, 0, 512, 512);
//		ObjRender_SetScaleXYZ(objText, 0.8, 0.8, 1);
		
		let alpha = 0;
		let before_index = Obj_GetValueD(objParent, "VALUE2", -1);
		while(!Obj_IsDeleted(parent))
		{
			let new_index = Obj_GetValueD(objParent, "VALUE2", -1);
			if (before_index != new_index)
			{
				break;
			}
			if (alpha < 1)
			{
				alpha = min(1, 0.1+alpha);
			}
			ObjRender_SetAlpha(objText, 255*alpha);
			yield;
		}
		descent(t in 0 .. 10)
		{
			let alpha = 255*((t+1)/10);
			ObjRender_SetAlpha(objText, alpha);
			yield;
		}
		Obj_Delete(objText);
	}
	task TMenuItemHelp(parent, index, base_x, base_y)
	{
		let objText = ObjPrim_Create(OBJ_SPRITE_2D);
		Obj_SetRenderPriorityI(objText, 91);
		ObjPrim_SetTexture(objText, imgHelp[0]);
		ObjRender_SetPosition(objText, base_x, base_y, 0);
		ObjSprite2D_SetSourceRect(objText, 0, index*32, 256, (index+1)*32);
		ObjSprite2D_SetDestCenter(objText);
		ObjRender_SetScaleXYZ(objText, 0.8, 0.8, 1);
		
		let base_alpha = 0;
		let alpha = 0;
		let before_index = -99999;
		while(!Obj_IsDeleted(parent))
		{
			let new_index = Obj_GetValueD(objParent, "VALUE", -1);
			if (Obj_GetValueD(objParent, "VALUE2", 0))
			{
				base_alpha = 64;
				before_index = -999;
			}
			else if (before_index != new_index)
			{
				base_alpha = [128, 255][new_index == index];
				before_index = new_index;
			}
			if (alpha < 1)
			{
				alpha = min(1, 0.1+alpha);
			}
			ObjRender_SetAlpha(objText, base_alpha*alpha);
			yield;
		}
		descent(t in 0 .. 10)
		{
			let alpha = base_alpha*((t+1)/10);
			ObjRender_SetAlpha(objText, alpha);
			yield;
		}
		Obj_Delete(objText);
	}
}


//キーリセットまで待機
function WaitForResetKey()
{
	while(GetVirtualKeyState(VK_OK) != KEY_FREE || GetVirtualKeyState(VK_CANCEL) != KEY_FREE) { yield; }
}
